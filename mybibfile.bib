@inproceedings{Pretnar:2010,
  author    = {Matija Pretnar},
  title     = {The Logic and Handling of Algebraic Effects},
  booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL)},
  year      = {2010},
  pages     = {333--344},
  publisher = {ACM},
  doi       = {10.1145/1706299.1706341}
}


@phdthesis{McLaughlin2020,
  author = {Craig McLaughlin},
  title  = {Type-and-Effect Reasoning with Algebraic Effects and Handlers},
  school = {University of Edinburgh},
  year   = {2020},
  url    = {https://hdl.handle.net/1842/40173}
}



@article{kiselyov2021extensible,
  author    = {Oleg Kiselyov and Myung-Chul Suh and Amr Sabry},
  title     = {Not by equations alone: Reasoning with extensible effects},
  journal   = {Journal of Functional Programming},
  volume    = {31},
  pages     = {e2},
  year      = {2021},
  doi       = {10.1017/S0956796820000271}
}


@article{plotkin_handling_2013,
	title = {Handling {Algebraic} {Effects}},
	volume = {Volume 9, Issue 4},
	copyright = {https://arxiv.org/licenses/nonexclusive-distrib/1.0},
	issn = {1860-5974},
	url = {https://lmcs.episciences.org/705},
	doi = {10.2168/LMCS-9(4:23)2013},
	abstract = {Algebraic effects are computational effects that can be represented by an
equational theory whose operations produce the effects at hand. The free model
of this theory induces the expected computational monad for the corresponding
effect. Algebraic effects include exceptions, state, nondeterminism,
interactive input/output, and time, and their combinations. Exception handling,
however, has so far received no algebraic treatment. We present such a
treatment, in which each handler yields a model of the theory for exceptions,
and each handling construct yields the homomorphism induced by the universal
property of the free model. We further generalise exception handlers to
arbitrary algebraic effects. The resulting programming construct includes many
previously unrelated examples from both theory and practice, including
relabelling and restriction in Milner's CCS, timeout, rollback, and stream
redirection.},
	language = {en},
	urldate = {2024-10-25},
	journal = {Logical Methods in Computer Science},
	author = {Plotkin, Gordon D and Pretnar, Matija},
	month = dec,
	year = {2013},
	pages = {705},
	annote = {[TLDR] This work generalises exception handlers to arbitrary algebraic effects, and includes many previously unrelated examples from both theory and practice, including relabelling and restriction in Milner's CCS, timeout, rollback, and stream redirection.},
	file = {Full Text PDF:C\:\\Users\\dougl\\Zotero\\storage\\XKEJKEEI\\Plotkin and Pretnar - 2013 - Handling Algebraic Effects.pdf:application/pdf},
}



@phdthesis{hillerstrom_foundations_nodate,
  author = {Daniel Hillerstr{\"{o}}m},
  title  = {Foundations for Programming and Implementing Effect Handlers},
  year   = 2022,
  school = {The University of Edinburgh, UK},
  url    = {http://dx.doi.org/10.7488/era/2122},
  doi    = {10.7488/era/2122},
}


@inproceedings{ocaml_effects,
	address = {New York, NY, USA},
	series = {{PLDI} 2021},
	title = {Retrofitting effect handlers onto {OCaml}},
	isbn = {978-1-4503-8391-2},
	url = {https://dl.acm.org/doi/10.1145/3453483.3454039},
	doi = {10.1145/3453483.3454039},
	abstract = {Effect handlers have been gathering momentum as a mechanism for modular programming with user-defined effects. Effect handlers allow for non-local control flow mechanisms such as generators, async/await, lightweight threads and coroutines to be composably expressed. We present a design and evaluate a full-fledged efficient implementation of effect handlers for OCaml, an industrial-strength multi-paradigm programming language. Our implementation strives to maintain the backwards compatibility and performance profile of existing OCaml code. Retrofitting effect handlers onto OCaml is challenging since OCaml does not currently have any non-local control flow mechanisms other than exceptions. Our implementation of effect handlers for OCaml: (i)\&nbsp;imposes a mean 1\% overhead on a comprehensive macro benchmark suite that does not use effect handlers; (ii)\&nbsp;remains compatible with program analysis tools that inspect the stack; and (iii)\&nbsp;is efficient for new code that makes use of effect handlers.},
	urldate = {2024-10-25},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Sivaramakrishnan, KC and Dolan, Stephen and White, Leo and Kelly, Tom and Jaffer, Sadiq and Madhavapeddy, Anil},
	month = jun,
	year = {2021},
	pages = {206--221},
	file = {Full Text PDF:C\:\\Users\\dougl\\Zotero\\storage\\QX9LILF2\\Sivaramakrishnan et al. - 2021 - Retrofitting effect handlers onto OCaml.pdf:application/pdf},
}

@article{pretnar_introduction_2015,
	title = {An {Introduction} to {Algebraic} {Effects} and {Handlers}. {Invited} tutorial paper},
	volume = {319},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {15710661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066115000705},
	doi = {10.1016/j.entcs.2015.12.003},
	abstract = {This paper is a tutorial on algebraic eﬀects and handlers. In it, we explain what algebraic eﬀects are, give ample examples to explain how handlers work, deﬁne an operational semantics and a type \& eﬀect system, show how one can reason about eﬀects, and give pointers for further reading.},
	language = {en},
	urldate = {2024-10-25},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Pretnar, Matija},
	month = dec,
	year = {2015},
	pages = {19--35},
	file = {PDF:C\:\\Users\\dougl\\Zotero\\storage\\WYAXU7SA\\Pretnar - 2015 - An Introduction to Algebraic Effects and Handlers. Invited tutorial paper.pdf:application/pdf},
}

@misc{koka_effects,
	title = {Koka: {Programming} with {Row} {Polymorphic} {Effect} {Types}},
	shorttitle = {Koka},
	url = {http://arxiv.org/abs/1406.2061},
	doi = {10.48550/arXiv.1406.2061},
	abstract = {We propose a programming model where effects are treated in a disciplined way, and where the potential side-effects of a function are apparent in its type signature. The type and effect of expressions can also be inferred automatically, and we describe a polymorphic type inference system based on Hindley-Milner style inference. A novel feature is that we support polymorphic effects through row-polymorphism using duplicate labels. Moreover, we show that our effects are not just syntactic labels but have a deep semantic connection to the program. For example, if an expression can be typed without an exn effect, then it will never throw an unhandled exception. Similar to Haskell's `runST` we show how we can safely encapsulate stateful operations. Through the state effect, we can also safely combine state with let-polymorphism without needing either imperative type variables or a syntactic value restriction. Finally, our system is implemented fully in a new language called Koka and has been used successfully on various small to medium-sized sample programs ranging from a Markdown processor to a tier-splitted chat application. You can try out Koka live at www.rise4fun.com/koka/tutorial.},
	urldate = {2024-10-25},
	publisher = {arXiv},
	author = {Leijen, Daan},
	month = jun,
	year = {2014},
	note = {arXiv:1406.2061},
	keywords = {Computer Science - Programming Languages},
	file = {Preprint PDF:C\:\\Users\\dougl\\Zotero\\storage\\WU2PXJ4Q\\Leijen - 2014 - Koka Programming with Row Polymorphic Effect Types.pdf:application/pdf;Snapshot:C\:\\Users\\dougl\\Zotero\\storage\\2LPRV53T\\1406.html:text/html},
}

@misc{eff_effects,
	title = {Programming with {Algebraic} {Effects} and {Handlers}},
	url = {http://arxiv.org/abs/1203.1539},
	doi = {10.48550/arXiv.1203.1539},
	abstract = {Eff is a programming language based on the algebraic approach to computational effects, in which effects are viewed as algebraic operations and effect handlers as homomorphisms from free algebras. Eff supports first-class effects and handlers through which we may easily define new computational effects, seamlessly combine existing ones, and handle them in novel ways. We give a denotational semantics of eff and discuss a prototype implementation based on it. Through examples we demonstrate how the standard effects are treated in eff, and how eff supports programming techniques that use various forms of delimited continuations, such as backtracking, breadth-first search, selection functionals, cooperative multi-threading, and others.},
	urldate = {2024-10-25},
	publisher = {arXiv},
	author = {Bauer, Andrej and Pretnar, Matija},
	month = mar,
	year = {2012},
	note = {arXiv:1203.1539},
	keywords = {Computer Science - Programming Languages},
	file = {Preprint PDF:C\:\\Users\\dougl\\Zotero\\storage\\URH6FV5F\\Bauer and Pretnar - 2012 - Programming with Algebraic Effects and Handlers.pdf:application/pdf;Snapshot:C\:\\Users\\dougl\\Zotero\\storage\\N2IEJUH9\\1203.html:text/html},
}

@inproceedings{haskell_effects,
	address = {Boston Massachusetts USA},
	title = {Extensible effects: an alternative to monad transformers},
	isbn = {978-1-4503-2383-3},
	shorttitle = {Extensible effects},
	url = {https://dl.acm.org/doi/10.1145/2503778.2503791},
	doi = {10.1145/2503778.2503791},
	abstract = {We design and implement a library that solves the long-standing problem of combining effects without imposing restrictions on their interactions (such as static ordering). Effects arise from interactions between a client and an effect handler (interpreter); interactions may vary throughout the program and dynamically adapt to execution conditions. Existing code that relies on monad transformers may be used with our library with minor changes, gaining efﬁciency over long monad stacks. In addition, our library has greater expressiveness, allowing for practical idioms that are inefﬁcient, cumbersome, or outright impossible with monad transformers.},
	language = {en},
	urldate = {2024-10-25},
	booktitle = {Proceedings of the 2013 {ACM} {SIGPLAN} symposium on {Haskell}},
	publisher = {ACM},
	author = {Kiselyov, Oleg and Sabry, Amr and Swords, Cameron},
	month = sep,
	year = {2013},
	pages = {59--70},
	file = {PDF:C\:\\Users\\dougl\\Zotero\\storage\\D9297Q55\\Kiselyov et al. - 2013 - Extensible effects an alternative to monad transformers.pdf:application/pdf},
}

@inproceedings{scala_effects,
	address = {Vancouver BC Canada},
	title = {Effekt: extensible algebraic effects in {Scala} (short paper)},
	isbn = {978-1-4503-5529-2},
	shorttitle = {Effekt},
	url = {https://dl.acm.org/doi/10.1145/3136000.3136007},
	doi = {10.1145/3136000.3136007},
	abstract = {Algebraic effects are an interesting way to structure effectful programs and offer new modularity properties. We present the Scala library Effekt, which is implemented in terms of a monad for multi-prompt delimited continuations and centered around capability passing. This makes the newly proposed feature of implicit function types a perfect fit for the syntax of our library. Basing the library design on capability passing and a polymorphic embedding of effect handlers furthermore opens up interesting dimensions of extensibility. Preliminary benchmarks comparing Effekt with an established library suggest significant speedups.},
	language = {en},
	urldate = {2024-10-25},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} {International} {Symposium} on {Scala}},
	publisher = {ACM},
	author = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp},
	month = oct,
	year = {2017},
	pages = {67--72},
	file = {PDF:C\:\\Users\\dougl\\Zotero\\storage\\Z9BBWZBL\\Brachthäuser and Schuster - 2017 - Effekt extensible algebraic effects in Scala (short paper).pdf:application/pdf},
}

@article{deep_handlers,
	title = {Effect handlers via generalised continuations},
	volume = {30},
	copyright = {https://www.cambridge.org/core/terms},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796820000040/type/journal_article},
	doi = {10.1017/S0956796820000040},
	abstract = {Plotkin and Pretnar’s effect handlers offer a versatile abstraction for modular programming with user-deﬁned effects. This paper focuses on foundations for implementing effect handlers, for the three different kinds of effect handlers that have been proposed in the literature: deep, shallow, and parameterised.},
	language = {en},
	urldate = {2024-10-25},
	journal = {Journal of Functional Programming},
	author = {Hillerström, Daniel and Lindley, Sam and Atkey, Robert},
	year = {2020},
	pages = {e5},
	file = {PDF:C\:\\Users\\dougl\\Zotero\\storage\\8UJ8757K\\Hillerström et al. - 2020 - Effect handlers via generalised continuations.pdf:application/pdf},
}


@incollection{ryu_shallow_2018,
	address = {Cham},
	title = {Shallow {Effect} {Handlers}},
	volume = {11275},
	isbn = {978-3-030-02767-4 978-3-030-02768-1},
	url = {http://link.springer.com/10.1007/978-3-030-02768-1_22},
	abstract = {Plotkin and Pretnar’s eﬀect handlers oﬀer a versatile abstraction for modular programming with user-deﬁned eﬀects. Traditional deep handlers are deﬁned by folds over computation trees. In this paper we study shallow handlers, deﬁned instead by case splits over computation trees. We show that deep and shallow handlers can simulate one another up to speciﬁc notions of administrative reduction. We present the ﬁrst formal accounts of an abstract machine for shallow handlers and a Continuation Passing Style (CPS) translation for shallow handlers taking special care to avoid memory leaks. We provide implementations in the Links web programming language and empirically verify that neither implementation introduces unwarranted memory leaks.},
	language = {en},
	urldate = {2024-10-25},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Hillerström, Daniel and Lindley, Sam},
	editor = {Ryu, Sukyoung},
	year = {2018},
	doi = {10.1007/978-3-030-02768-1_22},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {415--435},
	file = {PDF:C\:\\Users\\dougl\\Zotero\\storage\\8YNZUETJ\\Hillerström and Lindley - 2018 - Shallow Effect Handlers.pdf:application/pdf},
}



@inproceedings{bauer_effect_2013,
	address = {Berlin, Heidelberg},
	title = {An {Effect} {System} for {Algebraic} {Effects} and {Handlers}},
	isbn = {978-3-642-40206-7},
	doi = {10.1007/978-3-642-40206-7_1},
	abstract = {We present an effect system for algebraic effects and handlers. Because handlers may transform an effectful computation into a pure one, the effect system is non-monotone in the sense that effects do not just accumulate, but may also be deleted from types or generally transformed. We also provide denotational semantics for the effect system, based on a domain-theoretic model with partial equivalence relations. The semantics validates equational reasoning about effectful computations.},
	language = {en},
	booktitle = {Algebra and {Coalgebra} in {Computer} {Science}},
	publisher = {Springer},
	author = {Bauer, Andrej and Pretnar, Matija},
	editor = {Heckel, Reiko and Milius, Stefan},
	year = {2013},
	keywords = {Computation Type, Denotational Semantic, Expression Type, Transactional Memory, Typing Rule},
	pages = {1--16},
	file = {Full Text PDF:C\:\\Users\\dougl\\Zotero\\storage\\58RXC7SL\\Bauer and Pretnar - 2013 - An Effect System for Algebraic Effects and Handlers.pdf:application/pdf},
}

@misc{posix,
  title        = {IEEE Std 1003.1-2017 (POSIX.1)},
  howpublished = {\url{https://pubs.opengroup.org/onlinepubs/9799919799/}},
  note         = {The Open Group Base Specifications Issue 7},
  year         = {2018}
}